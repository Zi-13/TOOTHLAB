ğŸ¯ é¡¹ç›®æ ¸å¿ƒé€»è¾‘
å»ºç«‹æ¨¡æ¿åº“ï¼šä»3Då»ºæ¨¡æˆªå›¾ä¸­æå–æ‰€æœ‰æ¨¡å‹è½®å»“ â†’ å­˜å‚¨åˆ°æ•°æ®åº“
å®æ—¶è¯†åˆ«ï¼šæ‹æ‘„ç°å®æ¨¡å‹ â†’ æå–è½®å»“ â†’ åŒ¹é…æ•°æ®åº“ â†’ è¿”å›ç¼–å·å’Œæ“ä½œæŒ‡ä»¤
è¿™æ˜¯ä¸€ä¸ªåŸºäºè½®å»“åŒ¹é…çš„å·¥ä¸šè¯†åˆ«ç³»ç»Ÿï¼

ğŸ› ï¸ å®ç°è·¯å¾„è§„åˆ’
é˜¶æ®µ1ï¼šæ•°æ®å­˜å‚¨ç³»ç»Ÿ ğŸ“š
ç›®æ ‡ï¼šæŠŠä½ ç°æœ‰çš„è½®å»“æå–å·¥å…·å‡çº§ï¼Œæ”¯æŒæ‰¹é‡å»ºåº“

æŠ€æœ¯æ–¹æ¡ˆï¼š

å­˜å‚¨æ ¼å¼ï¼šJSON + SQLiteæ··åˆæ–¹æ¡ˆ
JSONå­˜å‚¨è½®å»“ç‚¹åæ ‡ï¼ˆæ˜“è¯»æ˜“è°ƒè¯•ï¼‰
SQLiteå­˜å‚¨ç´¢å¼•å’Œå…ƒæ•°æ®ï¼ˆå¿«é€ŸæŸ¥è¯¢ï¼‰
æ•°æ®ç»“æ„ï¼š


é˜¶æ®µ2ï¼šè½®å»“ç‰¹å¾æå– ğŸ”
ç›®æ ‡ï¼šæå–å¯æ¯”è¾ƒçš„ç‰¹å¾å‘é‡

æŠ€æœ¯æ–¹æ¡ˆï¼š

å‡ ä½•ç‰¹å¾ï¼šé¢ç§¯ã€å‘¨é•¿ã€é•¿å®½æ¯”ã€åœ†å½¢åº¦
å½¢çŠ¶æè¿°ç¬¦ï¼šHuçŸ©ã€å‚…é‡Œå¶æè¿°ç¬¦ï¼ˆç®€åŒ–ç‰ˆï¼‰
å…³é”®ç‚¹ç‰¹å¾ï¼šè§’ç‚¹ã€å‡¸åŒ…ç‚¹
å½’ä¸€åŒ–å¤„ç†ï¼šæ¶ˆé™¤å°ºå¯¸ã€æ—‹è½¬ã€å¹³ç§»å½±å“


é˜¶æ®µ3ï¼šç›¸ä¼¼åº¦åŒ¹é…ç®—æ³• ğŸ¯
ç›®æ ‡ï¼šå¿«é€Ÿå‡†ç¡®åœ°æ‰¾åˆ°æœ€ç›¸ä¼¼æ¨¡å‹

æŠ€æœ¯æ–¹æ¡ˆï¼š

ç²—åŒ¹é…ï¼šåŸºäºå‡ ä½•ç‰¹å¾å¿«é€Ÿç­›é€‰å€™é€‰é¡¹
ç²¾åŒ¹é…ï¼šè½®å»“ç‚¹è·ç¦»è®¡ç®—ï¼ˆHausdorffè·ç¦»ï¼‰
å¤šå°ºåº¦åŒ¹é…ï¼šå¤„ç†ä¸åŒæ‹æ‘„è§’åº¦å’Œè·ç¦»
ç½®ä¿¡åº¦è¯„åˆ†ï¼šç»™å‡ºåŒ¹é…å¯é æ€§


é˜¶æ®µ4ï¼šWebç•Œé¢/API ğŸŒ
ç›®æ ‡ï¼šå®ç”¨çš„æ“ä½œç•Œé¢

æŠ€æœ¯æ–¹æ¡ˆï¼š

æ¨¡æ¿å½•å…¥ç•Œé¢ï¼šæ‰¹é‡å¤„ç†3Dæˆªå›¾ï¼Œäººå·¥ç¡®è®¤ç¼–å·
è¯†åˆ«ç•Œé¢ï¼šä¸Šä¼ ç°å®ç…§ç‰‡ï¼Œæ˜¾ç¤ºåŒ¹é…ç»“æœ
ç®¡ç†ç•Œé¢ï¼šç¼–è¾‘æ¨¡å‹ä¿¡æ¯ã€æ“ä½œæŒ‡ä»¤

ğŸ“‹ å…·ä½“å®ç°æ­¥éª¤

Step 1: æ‰©å±•ç°æœ‰å·¥å…·
åœ¨ä½ çš„DrawTheEdge_withoutfourier.pyåŸºç¡€ä¸Šï¼š

æ·»åŠ "æ¨¡æ¿å½•å…¥æ¨¡å¼"å’Œ"è¯†åˆ«åŒ¹é…æ¨¡å¼"
å®ç°è½®å»“æ•°æ®çš„JSONåºåˆ—åŒ–å­˜å‚¨
æ·»åŠ ç‰¹å¾æå–å‡½æ•°

Step 2: å»ºç«‹æ•°æ®åº“schema

Step 3: æ ¸å¿ƒåŒ¹é…ç®—æ³•
å®ç°è½®å»“ç›¸ä¼¼åº¦è®¡ç®—
å»ºç«‹ç‰¹å¾ç´¢å¼•åŠ é€ŸæŸ¥è¯¢
è®¾è®¡åŒ¹é…é˜ˆå€¼å’Œç­–ç•¥

Step 4: é›†æˆæµ‹è¯•
ç”¨ä½ çš„3Dæˆªå›¾å»ºç«‹å°è§„æ¨¡æ¨¡æ¿åº“
æ‹æ‘„å¯¹åº”æ¨¡å‹æµ‹è¯•è¯†åˆ«å‡†ç¡®ç‡
ä¼˜åŒ–å‚æ•°å’Œç®—æ³•

ğŸ”§ æŠ€æœ¯éš¾ç‚¹å’Œè§£å†³æ–¹æ¡ˆ
éš¾ç‚¹1ï¼šä¸åŒæ‹æ‘„è§’åº¦

è§£å†³ï¼šå¤šè§’åº¦æ¨¡æ¿ + 3Dè½®å»“æŠ•å½±ç®—æ³•

éš¾ç‚¹2ï¼šå…‰ç…§å˜åŒ–å½±å“è¾¹ç¼˜æå–

è§£å†³ï¼šHSVé¢œè‰²ç©ºé—´ + è‡ªé€‚åº”é˜ˆå€¼

éš¾ç‚¹3ï¼šå®æ—¶æ€§è¦æ±‚

è§£å†³ï¼šç‰¹å¾ç´¢å¼• + åˆ†å±‚åŒ¹é…ç­–ç•¥

éš¾ç‚¹4ï¼šç›¸ä¼¼æ¨¡å‹åŒºåˆ†

è§£å†³ï¼šå±€éƒ¨ç‰¹å¾ + ç»†èŠ‚æƒé‡






import cv2
import numpy as np
import matplotlib.pyplot as plt
from numpy.linalg import lstsq
import matplotlib
import json
from pathlib import Path

INPUT = 'c:\\Users\\Administrator\\Desktop\\ya.jpg'  # è¾“å…¥å›¾ç‰‡è·¯å¾„

matplotlib.rcParams['font.sans-serif'] = ['SimHei']  # é»‘ä½“
matplotlib.rcParams['axes.unicode_minus'] = False

def fit_fourier_series(data, t, order):
    A = np.ones((len(t), 2 * order + 1))
    for k in range(1, order + 1):
        A[:, 2 * k - 1] = np.cos(k * t)
        A[:, 2 * k] = np.sin(k * t)
    coeffs, _, _, _ = lstsq(A, data, rcond=None)
    return coeffs

def evaluate_fourier_series(coeffs, t, order):
    A = np.ones((len(t), 2 * order + 1))
    for k in range(1, order + 1):
        A[:, 2 * k - 1] = np.cos(k * t)
        A[:, 2 * k] = np.sin(k * t)
    return A @ coeffs

def fourier_fit_and_plot(points, order, label='å‚…é‡Œå¶æ‹Ÿåˆè½®å»“', linewidth=1.2):
    try:
        x = points[:, 0]
        y = points[:, 1]
        N = len(points)
        t = np.linspace(0, 2 * np.pi, N)
        coeffs_x = fit_fourier_series(x, t, order)
        coeffs_y = fit_fourier_series(y, t, order)
        x_fit = evaluate_fourier_series(coeffs_x, t, order)
        y_fit = evaluate_fourier_series(coeffs_y, t, order)
        plt.plot(x, y, 'k.', markersize=1, alpha=0.3)  # åŸå§‹ç‚¹æ·¡åŒ–
        plt.plot(x_fit, y_fit, '-', linewidth=linewidth, label=label)
    except Exception as e:
        print(f"[å‚…é‡Œå¶æ‹Ÿåˆå¤±è´¥]ï¼š{e}")

def pick_color_and_draw_edge(image_path):
    img = cv2.imread(image_path)
    if img is None:
        print("å›¾ç‰‡è¯»å–å¤±è´¥")
        return
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    picked = []
    def on_mouse(event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            color = hsv[y, x]
            print(f"é€‰ä¸­ç‚¹HSV: {color}")
            picked.append(color)
    cv2.imshow("ç‚¹å‡»é€‰å–ç›®æ ‡åŒºåŸŸé¢œè‰²", img)
    cv2.setMouseCallback("ç‚¹å‡»é€‰å–ç›®æ ‡åŒºåŸŸé¢œè‰²", on_mouse)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    if not picked:
        print("æœªé€‰å–é¢œè‰²")
        return
    hsv_arr = np.array(picked)
    h, s, v = np.mean(hsv_arr, axis=0).astype(int)
    print(f"HSV picked: {h}, {s}, {v}")
    lower = np.array([max(h-15,0), max(s-60,0), max(v-60,0)])
    upper = np.array([min(h+15,179), min(s+60,255), min(v+60,255)])
    print(f"lower: {lower}, upper: {upper}")
    mask = cv2.inRange(hsv, lower, upper)
    color_extract = cv2.bitwise_and(img, img, mask=mask)
    # --- è®°å½•æ‰€æœ‰æœ‰æ•ˆè½®å»“åŠå±æ€§ ---
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    valid_contours = []
    for i, contour in enumerate(contours):
        if contour.shape[0] < 20:
            continue
        area = cv2.contourArea(contour)
        length = cv2.arcLength(contour, True)
        valid_contours.append({
            'contour': contour,
            'points': contour[:, 0, :],
            'area': area,
            'length': length,
            'idx': i
        })
    n_contours = len(valid_contours)
    linewidth = max(0.5, 2 - 0.03 * n_contours)
    show_legend = n_contours <= 15
    # --- äº¤äº’å¼æ˜¾ç¤º ---
    fig, axes = plt.subplots(1, 3, figsize=(16, 6))
    ax_img, ax_fit, ax_zoom = axes
    ax_img.set_title("é¢œè‰²æå–ç»“æœ")
    ax_img.imshow(cv2.cvtColor(color_extract, cv2.COLOR_BGR2RGB))
    ax_img.axis('off')
    ax_fit.set_title("è½®å»“æ˜¾ç¤º")
    ax_fit.axis('equal')
    ax_fit.invert_yaxis()
    ax_fit.grid(True)
    ax_zoom.set_title("è‰²å—æ”¾å¤§è§†å›¾")
    ax_zoom.axis('equal')
    ax_zoom.grid(True)
    selected_idx = [0]  # ç”¨åˆ—è¡¨åŒ…è£¹ä»¥ä¾¿é—­åŒ…ä¿®æ”¹
    info_text = None
    def draw_all(highlight_idx=None):
        ax_fit.clear()
        ax_fit.set_title("è½®å»“æ˜¾ç¤º")
        ax_fit.axis('equal')
        ax_fit.invert_yaxis()
        ax_fit.grid(True)
        
        # å‡†å¤‡é¢œè‰²åˆ—è¡¨
        colors = plt.cm.tab10(np.linspace(0, 1, max(len(valid_contours), 10)))
        
        for j, info in enumerate(valid_contours):
            points = info['points']
            label = f"è‰²å—{info['idx']+1}"
            
            if highlight_idx is not None and j == highlight_idx:
                fill_color = 'red'
                edge_color = 'darkred'
                lw = linewidth * 2
                alpha = 0.7
                zorder = 10
            else:
                fill_color = colors[j % len(colors)]
                edge_color = 'black'
                lw = linewidth
                alpha = 0.5
                zorder = 1
            
            x = points[:, 0]
            y = points[:, 1]
            
            # å¡«å……è‰²å—åŒºåŸŸ
            ax_fit.fill(x, y, color=fill_color, alpha=alpha, zorder=zorder, label=label if show_legend else None)
            # ç»˜åˆ¶è½®å»“è¾¹ç•Œ
            ax_fit.plot(x, y, '-', color=edge_color, linewidth=lw, zorder=zorder+1)
            
        if show_legend:
            ax_fit.legend()
        # --- å±æ€§ä¿¡æ¯æ˜¾ç¤ºåœ¨å³å›¾ä¸‹æ–¹ ---
        info = valid_contours[highlight_idx if highlight_idx is not None else 0]
        ax_fit.text(0.02, -0.12, f"è‰²å—ç¼–å·: {info['idx']+1}  é¢ç§¯: {info['area']:.2f}  å‘¨é•¿: {info['length']:.2f}",
                    transform=ax_fit.transAxes, fontsize=12, color='red', va='top')
        # --- æ”¾å¤§è§†å›¾ ---
        ax_zoom.clear()
        ax_zoom.set_title("è‰²å—æ”¾å¤§è§†å›¾")
        ax_zoom.axis('equal')
        ax_zoom.invert_yaxis()
        ax_zoom.grid(True)
        points = info['points']
        x = points[:, 0]
        y = points[:, 1]
        
        # åœ¨æ”¾å¤§è§†å›¾ä¸­ä¹Ÿæ˜¾ç¤ºå¡«å……
        if highlight_idx is not None:
            fill_color = 'red'
            alpha = 0.7
        else:
            fill_color = colors[0 % len(colors)]
            alpha = 0.5
            
        # å¡«å……åŒºåŸŸ
        ax_zoom.fill(x, y, color=fill_color, alpha=alpha, label='å¡«å……åŒºåŸŸ')
        # ç»˜åˆ¶è½®å»“ç‚¹å’Œè¿çº¿
        ax_zoom.plot(x, y, 'k.', markersize=2, alpha=0.8, label='è½®å»“ç‚¹')
        ax_zoom.plot(x, y, 'black', linewidth=2, label='è½®å»“çº¿')
        ax_zoom.legend()
        # è‡ªé€‚åº”ç¼©æ”¾
        margin = 20
        ax_zoom.set_xlim(x.min()-margin, x.max()+margin)
        ax_zoom.set_ylim(y.min()-margin, y.max()+margin)
        fig.canvas.draw_idle()
    def show_info(idx):
        # å·²é›†æˆåˆ°draw_allä¸­ï¼Œæ— éœ€å•ç‹¬æ˜¾ç¤º
        pass
    def on_click(event):
        if event.inaxes not in [ax_img, ax_fit, ax_zoom]:
            return
        x, y = int(event.xdata), int(event.ydata)
        found = False
        for j, info in enumerate(valid_contours):
            if cv2.pointPolygonTest(info['contour'], (x, y), False) >= 0:
                selected_idx[0] = j
                draw_all(highlight_idx=j)
                found = True
                break
        if not found:
            print("æœªé€‰ä¸­ä»»ä½•è‰²å—")
    def on_key(event):
        if event.key == 'right':
            selected_idx[0] = (selected_idx[0] + 1) % n_contours
            draw_all(highlight_idx=selected_idx[0])
        elif event.key == 'left':
            selected_idx[0] = (selected_idx[0] - 1) % n_contours
            draw_all(highlight_idx=selected_idx[0])
    draw_all(highlight_idx=selected_idx[0])
    fig.canvas.mpl_connect('button_press_event', on_click)
    fig.canvas.mpl_connect('key_press_event', on_key)
    plt.tight_layout()
    plt.show()

def load_contour_database(database_dir):
    """åŠ è½½æ•°æ®åº“ä¸­çš„è½®å»“æ•°æ®"""
    database_dir = Path(database_dir)
    contours = []
    for json_file in database_dir.glob("*.json"):
        with open(json_file, "r") as f:
            data = json.load(f)
            contours.append(data)
    return contours

def match_contours(input_contours, database_contours):
    """åŒ¹é…è¾“å…¥è½®å»“ä¸æ•°æ®åº“è½®å»“"""
    best_match = None
    best_score = float("inf")

    for db_entry in database_contours:
        for db_contour in db_entry["contours"]:
            db_points = np.array(db_contour["points"])
            for input_contour in input_contours:
                input_points = input_contour["points"]
                score = cv2.matchShapes(input_points, db_points, cv2.CONTOURS_MATCH_I1, 0.0)
                if score < best_score:
                    best_score = score
                    best_match = db_entry

    return best_match, best_score

def recognize_image(image_path, database_dir):
    """è¯†åˆ«è¾“å…¥å›¾åƒä¸­çš„è½®å»“"""
    # æå–è¾“å…¥å›¾åƒçš„è½®å»“
    img = cv2.imread(image_path)
    if img is None:
        print("å›¾ç‰‡è¯»å–å¤±è´¥")
        return

    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, (0, 0, 0), (179, 255, 255))  # ç¤ºä¾‹é˜ˆå€¼
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

    input_contours = []
    for contour in contours:
        if contour.shape[0] < 20:
            continue
        input_contours.append({"points": contour[:, 0, :]})

    # åŠ è½½æ•°æ®åº“è½®å»“
    database_contours = load_contour_database(database_dir)

    # åŒ¹é…è½®å»“
    best_match, best_score = match_contours(input_contours, database_contours)

    if best_match:
        print(f"åŒ¹é…æˆåŠŸ: {best_match['tooth_id']}ï¼Œå¾—åˆ†: {best_score}")
    else:
        print("æœªæ‰¾åˆ°åŒ¹é…é¡¹")
        
def main():
    pick_color_and_draw_edge(INPUT) 
    recognize_image(INPUT, "c:\\Users\\Administrator\\Desktop\\è¯†åˆ«æµ‹è¯•\\templates\\contours")
if __name__ == "__main__":
    main()

